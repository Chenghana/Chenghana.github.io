---
title: 函数
date: 2022-08-02 15:38:38
permalink: /pages/41a341/
author: 
  name: niko
  link: https://github.com/niko
---
## 函数

### 1.1 函数的概念

>在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。
>
>函数：就是**封装了一段可被重复调用执行的代码块**。通过此代码块可以**实现大量代码的重复使用**。

  

### 1.2函数的使用

#### **声明函数**

```js
// 声明函数
function 函数名() {
    //函数体代码
}
```

- function 是声明函数的关键字,必须小写

- 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum

#### 调用函数

```js
// 调用函数
函数名();  // 通过调用函数名来执行函数体代码
```

- 调用的时候千万不要忘记添加小括号

- 口诀：函数不调用，自己不执行

  注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

#### 函数的封装

- 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口

- 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）  

![image-20220802154259575](https://typorayyds.oss-cn-beijing.aliyuncs.com/img/202208021542613.png)

例子：封装计算1-100累加和

```js
// 声明函数
function getSum(){
  var sumNum = 0;// 准备一个变量，保存数字和
  for (var i = 1; i <= 100; i++) {
    sumNum += i;// 把每个数值 都累加 到变量中
  }
  alert(sumNum);
}
// 调用函数
getSum();
```

### 1.3 函数的参数

#### 函数参数语法

- 形参：函数定义时设置接收调用时传入

- 实参：函数调用时传入小括号内的真实数据

![image-20220802154404064](https://typorayyds.oss-cn-beijing.aliyuncs.com/img/202208021544101.png)

> 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去

函数参数的运用：

```js
// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...); 
```

1. 调用的时候实参值是传递给形参的
2. 形参简单理解为：不用声明的变量
3. 实参和形参的多个参数之间用逗号（,）分隔

#### 函数形参和实参数量不匹配时

![image-20220802154537842](https://typorayyds.oss-cn-beijing.aliyuncs.com/img/202208021545876.png)

> 注意：在JavaScript中，形参的默认值是undefined。

小结：

-  函数可以带参数也可以不带参数
-  声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined
-  调用函数的时候，函数名括号里面的是实参
-  多个参数中间用逗号分隔
-  形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配

### 1.4 函数的返回值

#### return 语句

> 返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。

```js
// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
```

-  在使用 return 语句时，函数会停止执行，并返回指定的值
-  如果函数没有 return ，返回的值是 undefined

#### break ,continue ,return 的区别

- break ：结束当前的循环体（如 for、while）
- continue ：跳出本次循环，继续执行下次循环（如 for、while）
- return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码

### 1.5 arguments的使用

​		当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：

- 具有 length 属性

- 按索引方式储存数据

- 不具有数组的 push , pop 等方法

  注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。

###  1.6函数的两种声明方式

- 自定义函数方式(命名函数)

  利用函数关键字 function 自定义函数方式

  ```js
  // 声明定义方式
  function fn() {...}
  // 调用  
  fn();  
  ```

  - 因为有名字，所以也被称为命名函数
  - 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面

- 函数表达式方式(匿名函数）

  利用函数表达式方式的写法如下： 

  ```js
  // 这是函数表达式写法，匿名函数后面跟分号结束
  let fn = function(){...}；
  // 调用的方式，函数调用必须写到函数体下面
  fn();
  ```

  - 因为函数没有名字，所以也被称为匿名函数
  - 这个fn 里面存储的是一个函数  
  - 函数表达式方式原理跟声明变量方式是一致的
  - 函数调用的代码必须写到函数体后面

## 作用域和作用域链



![image-20220802163656377](https://typorayyds.oss-cn-beijing.aliyuncs.com/img/202208021641252.png)![image-20220802164027035](https://typorayyds.oss-cn-beijing.aliyuncs.com/img/202208021641189.png)

> 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

- 全局作用域
- 局部作用域（函数作用域）	
- 块级作用域

### 2.1全局作用域

```js
作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。
```

### 2.2局部作用域

```js
//作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。
<script>
let a = 1       //全局变量
function fn(){
    let a = 10  //局部变量
    function fn1(){
        console.log(a) // a=10
    }
    fn1()
}
fn()
</script>
```

### 2.3块级作用域

```js
块级作用域 {}包括，if语句和for循环语句中的{}
if(true){
    let num =10;
}
console.log(num) //块级作用域报错
for(let i=0;i<5;i++){
    console.log(i)
}
console.log(i) //块级作用域报错
```

### 2.4特殊情况

![image-20220802165524068](https://typorayyds.oss-cn-beijing.aliyuncs.com/img/202208021655110.png)

```js
if（true）{
    num=10
}
console.log(num)  //num=10
--------------------------------
fun(x,y){
    console.log(x,y)   // 1,2
}
fun(1,2)  
console.log(x)  //报错
```

### 2.5作用域链

> 只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
>
> 根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链
>
> 作用域链：采取就近原则的方式来查找变量最终的值。

```js
案例分析1：
let num=10
function f1() {
    let num = 123
    console.log(num)
}
f1()
```

## 预解析

### 3.1 预解析的相关概念

	JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。

- 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。

- 代码执行： 从上到下执行JS语句。

  **预解析会把var定义的变量和函数的声明在代码执行之前执行完成。**

### 3.2 变量预解析

	预解析也叫做变量、函数提升。
	变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。

```js
console.log(num);  // 结果是多少？
var num = 10;      // ？
```

	结果：undefined
	
	注意：**变量提升只提升声明，不提升赋值**

### 3.3 函数预解析

	函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。

```js
fn();
function fn() {
    console.log('打印');
}
```

	结果：控制台打印字符串 --- ”打印“ 
	
	注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	

### 3.4 函数表达式声明函数问题

	函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：

```js
fn();
var  fn = function() {
    console.log('想不到吧');
}
```

	结果：报错提示 ”fn is not a function"
	
	解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用
